\section{Introduction}
%123456789123456789123456789123456789123456789123456789123456789
The increase demands of services and computational applications 
from {\sc ict}-related products are the major facts contributing 
to increase energy consumption.{\footnote{Although in the physical sense energy 
		cannot be consumed, we will use the terms energy ``consumption'', 
		``requirement'', and ``usage'' to refer to the conversion of 
		electrical energy by {\sc ict} equipment into thermal energy 
		dissipation to the environment. 
		Correspondingly, we will use the term energy ``savings", 
		``reduction", ``efficiency", and ``optimization" to refer 
		to reduced consumption}} 
Recent results obtained by Gelenbe and Caseau~\shortcite{ICT_energy_impact_1} and 
Van Heddeghem et al.~\shortcite{ICT_energy_impact_2} indicates the 
raising course of the {\sc it}'s sector energy requirements, which are 
expected to reach 15\% of the world's total energy consumption 
by 2020. 
Moreover, recent results outline, also, raise of green house gas 
emissions due to the {\sc it}-sector which are growing much faster 
than initially predicted and are estimated around 2.3\% globally, as 
claimed in {\sc smart}er2030\footnote{http://smarter2030.gesi.org/downloads.php} 
report.
Therefore, providing energy efficiency at different fields of 
{\sc it} is essential and of paramount importance, since the fact 
does not only contributes economically but also environmentally. 

%123456789123456789123456789123456789123456789123456789123456789
% Why is importat for software engineering and what are the 
% current trend and goal show the scale of a change...
Traditionally, most of the studies, regarding energy efficiency, 
considered energy consumption at hardware level. 
However, nowadays, there is much of evidence that software can also 
alter energy dissipation significantly \cite{eder_energy_consumptions, 
capra_is_2012, ferreira_seflab_2013}. 
In fact, some researchers showed by using inefficient design patterns 
or data structures can increase energy dissipation up to
300--700\% \cite{sahin_initial_2012, hasan_energy_profile_for_java_collection_classes_2016}. 
Nevertheless, even by applying minor modifications in application's 
energy usage can contribute to large scale changes if taken into 
account the amount of available {\sc pc}-like mobile devices and 
data-centers' servers.


%123456789123456789123456789123456789123456789123456789123456789
%How to achieve this and 
In order to reduce energy consumption in software development, 
we conducted an empirical study aiming to elicit energy usage 
results from small tasks implemented in a variety of 
programming languages.
Prior work only focused an a small number of programming languages 
which are mostly used in Android development such as Java and 
JavaScript or C and  C++, by making use of Native Development Kit\footnote{https://developer.android.com/ndk/index.html} library.
Therefore, our aim in this research is to identify which 
programming languages offer more energy efficient implementations 
for different tasks.


%123456789123456789123456789123456789123456789123456789123456789
%Paper's remainder.
The remainder of this paper is organized as follows.
In Section~\ref{related_work}, we discuss prior work done in the 
field and compare it with ours. 
Section~\ref{experiment_setup} describes in details our experimental 
platform, the software and the hardware tools we used, how we 
refined our dataset, and our methodology for retrieve our results. 
In Section~\ref{results_and_discussion}, we provide a discussion 
based on our preliminary results and Section~\ref{threats_of_validity} 
details threats of validity.
Finally, we conclude in Section~\ref{conclusiona_and_future_work} 
and we discuss future work and possible directions for this 
research.


\section{Related Work} \label{related_work}

\section{Experiment Setup} \label{experiment_setup}
%123456789123456789123456789123456789123456789123456789123456789
In this Section, we describe the experimental approach we 
used in order to perform our research and retrieve our 
measurements. 
Initially, we provide information about our dataset 
and the ways we decided to select our tasks and 
refine it.
Furthermore, we explain the setup up of our experimental 
platform, the additional hardware tools, and the software 
tools used to conduct this research. 
Moreover, we argue on the selected tasks and programming 
languages we used and the way re refined our dataset.

\subsection{Dataset}
%123456789123456789123456789123456789123456789123456789123456789
In the context of study, we used Rosetta 
Code,\footnote{http://rosettacode.org/wiki/Rosetta\_Code} a 
publicly available programming chromatography site that offers 
851 tasks, 230 draft tasks, and a collection of 658 different 
programming languages. In general, not all of (and cannot) tasks 
are implemented in all languages. 
We found and downloaded a git hub repository\footnote{https://github.com/acmeism/RosettaCodeData} 
which contains all the currently implemented tasks found on 
Rosetta Code website.

%123456789123456789123456789123456789123456789123456789123456789
For selecting the highly used programming languages, we made use 
of tiobe,\footnote{https://www.tiobe.com/tiobe-index/} a software 
quality company.
By making use of a formula\footnote{https://www.tiobe.com/tiobe-index/programming-languages-definition/}, 
25 of the highest ranked search engines (according to Alexa),\footnote{http://www.alexa.com/} 
and a number of requirements enlisted for programming languages, 
tiobe provides a search query for index rating of the most popular 
programming languages around the web for each month. 
Initially, we decided of choosing the top 15 programming languages 
as enlisted for June 2017. 
From the current list, we excluded programming languages such as 
Delphi and Assembly. 
In contrast, we included Rust in our dataset which a memory safe 
programming language and is gaining popularity in the web. \
Therefore, we ended up with 14 programming languages as illustrated 
in Table~\ref{Languages_Compilers_and_Interpreters}.

%123456789123456789123456789123456789123456789123456789123456789 
In terms of selecting tasks, we developed a shell script (more 
details in Subsection~\ref{software_components}) to identify 
which of the 851 tasks offers the most implementations for the 
programming languages of our selection. 
To refine further our dataset we used the following steps: 

\begin{enumerate}
	\item [$\bullet$] We excluded implemented tasks that are using 
	external libraries. 
	Since we would like to exploit the energy dissipation of 
	simple every day tasks, we decided to exclude form our dataset 
	the use of tasks requiring external libraries. 
	\item [$\bullet$] Some of the tasks offers more that one implementation 
	for the same programming languages. 
	Thus, we had to drive manually through each directory and remove 
	them until we have only one that is consistent with the other 
	implementation. 
	For example, palindrome in recursion we removed the iterative 
	implementations. 
	\item [$\bullet$] The Java file's names were 
	different from the public class names which results to compilation 
	error if not change accordingly. 
	\item [$\bullet$] Some of the implementations didn't have main 
	classes, nor the same data with other tasks. 
	Therefore, we change the source code to offer consistency.
	\item [$\bullet$] Some of the tasks are relatively small and may 
	finish faster than 1 second which makes it impossible for our 
	power analyzer to capture those results. 
	Therefore, we added all the selected tasks in a loop to iterate them 
	a million of times. 
\end{enumerate}


\subsection{Hardware and Software components}

\subsubsection{Hardware Components}
%123456789123456789123456789123456789123456789123456789123456789 
The physical tools composed mainly from a portable personal 
computer and a real-time electricity usage monitoring tool.
Our system's specifications are depicted in Table~\ref{laptop_specs}. 
The real-time power usage tools we used is the Watts Up Pro ({\sc wup}).\footnote{https://www.wattsupmeters.com/secure/products.php?pn=0} 

In general, there are two venues for retrieving energy consumption 
from a computer-based system: on one hand, by indirect energy measurements 
through estimation models or performance counters, core component 
of software monitoring tools, on the other hand, via direct measurement, 
hardware power analyzers and sensors.  
However, each approach has it own pitfalls such as: coarse-grained 
measurements for the whole systems' energy consumption and low sampling 
rate for direct measurements case and inaccuracy, lack of interoperability, 
and additional system overhead while using indirect measurements. 
Therefore, in our research we decided to retrieve our energy consumption 
measurements using direct approach such as {\sc wup} since our 
tasks are relatively short in terms of source-code lines.


In regards to {\sc wup}, it offers accuracy of \textpm1.5\% and 
as maximum sampling rate of 1 second. 
In order to retrieve power-related measurements from the {\sc wup} 
we used a software available in a Git repository.\footnote{https://github.com/pyrovski/watts-up}
This software helped us retrieve measurements such as timestamps, 
watts, volts, amps, etc. through a mini {\sc usb} interface after 
we integrated its code in our script that runs all the tasks.

\subsubsection{Software Components} \label{software_components}
%123456789123456789123456789123456789123456789123456789123456789 
To extract data, manage, and use our Rosetta Code Repository, 
we developed a number of shell scripts as enlisted below and are 
publicly available on our Git repository.\footnote{https://github.com/stefanos1316/Rosetta-Code-Research} 

\begin{enumerate}
	\item [$\bullet$] \textbf{script.cleanAll}, removes the current instance 
	of Tasks in the current working directory and copy the new one found 
	from in the parent directory. 
	\item [$\bullet$] \textbf{script.fromUpperToLower}, changes the current 
	instance of Tasks directory tree's letters from upper to lower 
	case to offer consistency for our scripts. 
	\item [$\bullet$] \textbf{script.findCommonTasksInLanguages}, provides 
	a list of tasks with the amount of programming language implementations.
	\item [$\bullet$] \textbf{script.createNewDataSet}, filters the Rosetta 
	Code current dataset and removes programming languages and tasks not 
	added as command line arguments.
	\item [$\bullet$] \textbf{script.compileTasks}, compiles all tasks found 
	under the Tasks' directory and produces error reports in a task fails to 
	compile.
	\item [$\bullet$] \textbf{script.executeTasks}, executes all the tasks' 
	implementations found in under Tasks directory.
	\item [$\bullet$] \textbf{script.plotGraphs}, after retrieving our data 
	we use this script to plot our graphs.
\end{enumerate}

%123456789123456789123456789123456789123456789123456789123456789 
Note that most of the scripts offer the \textit{--help} option 
that shows a list of available command line arguments in order 
use our scripts.
Moreover, users are suggested not to change the folders name or 
locations since most of our scripts are making use of them. 

For plotting our graphs we used FeedGnuplot,\footnote{http://search.cpan.org/~dkogan/feedgnuplot-1.44/bin/feedgnuplot} 
an open-source general purpose pipe-oriented plotting tool. 
To use our script for plotting graphs, someone has to provide a 
columned file with energy related measurements.

\begin{table}
		\begin{threeparttable}
	\caption{System hardware and software specifications}
	\label{laptop_specs}
	\begin{tabular}{cl}
		\toprule
		&Description\\
		\midrule
		Hardware	& HP EliteBook 840 G3, Intel Core i7-6500U \\
					& (2 physical cores of 2.5 GHz), 8 GB DDR4  \\
					& memory, 256 GB {\sc ssd}  hard disk \\
		Operating  System & Fedora 25 kernel version 4.11.5-200  \\			
		Software 	& {\sc wup} software (retrieving measurements \\
					& from the device), bash script, Java, R, \\
					& feedGnuplot \\
		\bottomrule
	\end{tabular}
	\end{threeparttable}
\end{table}

\begin{table}
	\begin{threeparttable}
	\caption{Programming Languages, Compilers and Interpreters}
	\label{Languages_Compilers_and_Interpreters}
	\begin{tabular}{cll}
		\toprule
		 & Programming  & Compilers and  \\
		 & Languages  &  Interpreters version\\
		\midrule
		Compiled&C, C++	& gcc version 6.3.1 20161221- \\
		&		& (Red Hat 6.3.1-1) (GCC) \\
		&Go		& go version go1.7.5  \\
		&Rust	& rustc version 1.18.0 \\
		&{\sc vb.net} & vbnc version 0.0.0.5943\tnote{a} \\
			\midrule
		Semi-&C\#		& mono version 4.4.2.0 (mics)\tnote{b} \\
		Compiled&Java	& javac version 1.8.0\_131 \\
			\midrule
		Interpreted&JavaScript & node version 6.10.3 \\
		&Perl	& perl version 5.24.1 \\
		&Php		& php version 7.0.19 \\
		&Python	& python version 2.7.13 \\
		&R		& Rscript version 3.3.3 \\
		&Ruby	& ruby version 2.3.3p222 \\
	
		&Swift 	& swift version 3.0.2\tnote{c} \\
		
		\bottomrule
	\end{tabular}
	\begin{tablenotes}
		\begin{small}
			\item[a] {http://www.mono-project.com/docs/about-mono/languages/visualbasic/}
			\item[b] {https://www.codetuts.tech/compile-c-sharp-command-line/}
			\item[c] {https://github.com/FedoraSwift/fedora-swift2/releases/tag/v0.0.2}
		\end{small}
	\end{tablenotes}
	\end{threeparttable}
\end{table}


\subsection{Retrieving Energy Measurements} 
%123456789123456789123456789123456789123456789123456789123456789 
As an initial step for our experiment, we shut down background 
process, as suggested by Hindle[...], found in modern {\sc os}s such as disk 
defragmentation, virus scanning, {\sc cron} jobs, automatic updates, 
disk indexing, document indexing, {\sc rss} feed updates, etc. to 
shorten some noise in our measurements. 
In addition, we set the network connection to flight mode and 
also reduced the brightness of the screen.
By making the following steps we reduced our platform's idle 
power usage from 8,6 watts to 5.8 watts. 
We estimated that after an {\sc os} (Operating System) is launched 
it's necessary to wait for a short time to reach a 
\textit{stable condition}.

%123456789123456789123456789123456789123456789123456789123456789 
After reaching \textit{stable condition}, we launched our main 
script \textit{i.e.,} \textbf{script.executeTasks}, that executes 
all the tasks implemented in different programming languages. 
While doing so, it retrieves power consumption and run-time 
performance measurements from {\sc wup} and through command 
time\footnote{https://linux.die.net/man/1/time} and stores them 
in timestamped directories which we are using later to plot 
our results. 
Between each executing of a task, we added a 
sleep\footnote{http://man7.org/linux/man-pages/man3/sleep.3.html} 
period of three minutes. 
The time gap purpose is to ensure our experimental platform 
reached a stable condition,\textit{e.g.,} the {\sc cpu} is cooled 
down and the fan is no longer consuming more power, to avoid 
unnecessary noise in our measurements.

\section{Results and Discussion} \label{results_and_discussion}
Graphs for programming languages using compilers and interpreters

\section{Threats of validity} \label{threats_of_validity}

\section{Conclusion and Future Work} \label{conclusiona_and_future_work}
Two Venues, Academic and Industrial.
She under the curtain and shed light... 
Compare PL in different CPU architectures such as 
ARM and AMD.
More tasks and different configuration and optimization 
flags.
Collect resource usage and system calls to identify 
relationship among them.

Future plans, micro-services proposition of tasks or 
programming languages after identifying the reasons


